<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>虚拟dom</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    
	<div id="app">
		<pre>
        Virtual Dom并不是真正意义上的DOM，而是一个轻量级的javascript对象，在状态发生变化时，
        Virtual Dom会进行Diff运算，来更新只需要被替换的DOM，而不是全部重绘。
                        与DOM操作相比，Virtual Dom是基于JavaScript计算的，所以开销会小很多。
        Virtual Dom就是通过一种VNode类表达的，每个DOM元素或组件都对应一个VNode对象，
                       在Vue中是这样定义的：
        export interface VNode {
        	tag?: string;  //当前节点的标签名
        	data?: VNodeData;//当前节点的数据对象
        	children?: VNode[];// 子节点，数组，也是VNode类型
        	text?: string;// 当前节点的文本，一般文本节点或注释节点会有该属性。
        	elm?: Node;// 当前虚拟节点对应的真实的DOM节点
        	ns?: string;// 节点的namespace
        	context?: Vue;//编译作用域
        	key?: string | number;// 节点的key属性，用于作为节点的标识，有利于patch的优化
        	componentOptins?: VNodeComponentOptions;// 创建组件实例时会用到的选项信息。
        	componentInstance?: Vue; // 当前节点对应的组件实例
        	parent?: VNode; // 组件的占位节点
        	raw?: boolean; //原始html
        	isStatic?: boolean;// 静态节点的标识
        	isRootInsert: boolean;// 是否作为根节点插入，被transition包裹的节点，该属性为false；
        	isComment: boolean;//当前节点是否是注释节点
        }
        VNode的类型：
        1、TextVNode: 文本节点
        2、ElementVNode: 普通元素节点
        3、ComponentVNode: 组件节点
        4、EmptyVNode: 没有内容的注释节点
        5、CloneVNode: 克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true。
        </pre>
        <index></index>
    </div>
    <script>
    	
    	var template = Vue.component('index', {
    		template: '<div>使用render渲染模板</div>'
    	});
    	
        var app = new Vue({

            //选择元素
            el: "#app",
            data: { //绑定数据到#app的实例上
                name: "qdi5"
            }
        });
		
    </script>
</body>
</html>
