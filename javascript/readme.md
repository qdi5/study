###Welcome to use MarkDown
### 一、正则表达式
#### 1.常用的贪婪型元字符和它们的懒惰型版本
|贪婪型元字符|懒惰型元字符|
|----|----|
|*|*?|
|+|+?|
|{n,}|{n,}?|
#### 2.单词边界
\b匹配的是一个这样的位置，这个位置位于一个能够用来构成单词的字符（字母、数字和下划线，也就是
与\w相匹配的字符）和一个不能用来构成单词的字符（也就是与\W相匹配的字符）之间。（也就是说，\b匹配的是\w与\W之间的一个看不见的位置）；
\B刚好与\b相反，所以只要记住\b就行。
#### 3.分行匹配
用来启用分行匹配模式的m修饰符，就是一个能够改变其他元字符行为的元字符序列。分行匹配模式将使得正则表达式引擎把
行分隔符当作一个字符串分隔符来对待。在分行匹配模式下，^不仅匹配正常的字符串开头，还将匹配行分隔符（换行符）后
面的开始位置（这个位置是不可见的）；类似地，$不仅匹配正常的字符串结尾，还将匹配行分隔符（换行符）后面的结束位置。
#### 4.子表达式
把一个表达式划分为一系列子表达式的目的是为了把那些子表达式当作一个独立元素来使用。子表达式必须用(和)括起来。
### 5.回溯引用
/<h([1-6])>.*?<\/h\1>/gi 匹配成对的h标签元素。这里的 \1引用的就是第一个子表达式匹配的内容
### 6.前后查找
  正则表达式标记要匹配的文本的位置（而不仅仅是文本本身）。前后查找，即对某一位置的前、后内容进行查找。它包含的匹配本身
  并不返回，而是用于确定正确的匹配位置，它并不是匹配结果的一部分。
6.1.向前查找
向前查找指定了一个必须匹配但不在结果中返回的模式。向前查找实际就是一个子表达式，而且从格式上看也确实如此。从语法上看，
一个向前查找模式其实就是一个以?=开头的子表达式，需要匹配的文本跟在=的后面。
```
let str = 'http://www.forta.com'
let regExp = /.+(?=:)\/\//gi
str.match(regExp)
```
以上正则匹配了http，没有匹配到:;它所代表的意思是：匹配当前子表达式对应的文本的位置的前面那个位置
6.2.先后查找  
向后查找。匹配当前子表达式对应的文本的位置的后面那个位置。
```
let dollar = 'ABC01: $23.45'
let dollarReg = /(?<=\$)[0-9.]+/g
console.log('匹配美元：\n', dollar.match(dollarReg))
```
6.3.结合向前查找和先后查找提取html标签里面的正文
```
let html = `<head>
		<title>trouble is friend<\/title>
	<\/head>`
let htmlReg = /(?<=\<title>).*(?=\<\/title>)/g
console.log(html.match(htmlReg))
```
6.5.负向前查找与负向后查找
负向前查找将向前查找不与给定模式相匹配的文本。
负向后查找将向后查找不与给定模式相匹配的文本。
6.4.前后查找操作符
|操作符|说明|
|----|----|
|(?=)|正向前查找|
|(?!)|负向前查找|
|(?<=)||